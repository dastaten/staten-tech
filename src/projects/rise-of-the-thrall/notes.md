## **FEATURES**

**Story:** There will be a basic story to set the stage at the beginning. The player is on a mission of revenge and will complete their journey in the final battle (if they make it that far).

---

**Character Creation:** Player can choose their name and gender. Stats sheet randomly generated upon character creation. (classes to be added later)

---

**Battle Mechanics:** Player will start with one attack and one defense move. New attacks and defense moves will be learned as the player levels up.

Each attack/defense move costs 'battle points'. Player will have a limited number of battle points to spend in each fight. Battle points are slowly regenerated with each turn. Player's battle points are increased as they level up.

Character's stats (strength, agility, perception, etc.) influence success or failure with attacks/defense moves.

---

**Healing:** Player will find healing potions and bandages as drops to use to heal during battle, though using these items will cost them their turn.

---

**Weapons and Armor:** Player will start with a weak sword and no armor. New weapons and armor (as well as gold) will be acquired as drops as the player wins battles.

Weapons and armor will have five tiers, ranging from weak to very powerful. The more powerful the item is, the more rare the drop.

1. **Weak** (common)
2. **Apprentice's** (fairly common)
3. **Journeyman's** (somewhat rare)
4. **Master's** (rare)
5. **Grandmaster's** (very rare)

---

**Shops:** Player will be able to visit shops from time to time to buy and sell weapons and armor.

---

## **STRUCTURE**

**Modular design:** Structure code using modules or classes for different game components (e.g., Player, Enemy, Item, Combat).

**Data-driven approach:** Store game data (weapons, armor, enemies) in JSON files or objects, demonstrating ability to work with data structures.

**Random elements:** Implement randomness in combat outcomes and item drops to add unpredictability to the game.

**Save/Load functionality:** Allow players to save and load their progress using local storage.

**Simple UI:** While keeping it text-based, use CSS to style the output and make it visually appealing.

**Error handling:** Implement robust error handling for invalid user inputs.

**Documentation:** Include clear comments and perhaps a brief design document explaining architecture decisions.
